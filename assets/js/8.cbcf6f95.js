(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{391:function(e,t,n){"use strict";n.r(t);var a=n(1),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("p",[e._v("内存泄漏\n")]),e._v(" "),n("h2",{attrs:{id:"什么是内存泄露"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么是内存泄露"}},[e._v("#")]),e._v(" 什么是内存泄露？")]),e._v(" "),n("p",[e._v("系统进程不在用到的内存没有及时释放，就叫做内存泄漏（memory leak）。当内存占用越来越高，轻则影响系统的性能，重则导致系统进程崩溃。Chrome限制了浏览器所能使用的内存极限（64位为1.4GB，32位为1.0GB）")]),e._v(" "),n("h2",{attrs:{id:"引起内存泄露的原因"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#引起内存泄露的原因"}},[e._v("#")]),e._v(" 引起内存泄露的原因")]),e._v(" "),n("ul",[n("li",[n("code",[e._v("意外的全局变量")]),e._v("\n由于js对未声明变量的处理方式是在全局对象上创建该变量的引用。如果在浏览器中，全局的对象就是windows对象。变量在窗口关闭或者重新刷新页面之前都不会被释放，如果未声明的变量缓存大量的数据，就会导致内存泄露。")])]),e._v(" "),n("p",[n("code",[e._v("未声明变量")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function fn() {  \n    a = 'global variable'\n  }\n  fn()\n")])])]),n("p",[n("code",[e._v("使用this创建的变量（this的指向是windows）")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function fn(){ \n  this.a='global'\n }\n fn()\n")])])]),n("p",[n("code",[e._v("解决方法")]),e._v("：")]),e._v(" "),n("ul",[n("li",[e._v("避免创建全局变量")]),e._v(" "),n("li",[e._v("使用严格模式，在"),n("code",[e._v("JavaScript")]),e._v("文件头部或者函数的顶部加上"),n("code",[e._v("use strict")]),e._v("。")])]),e._v(" "),n("h2",{attrs:{id:"闭包引起的内存泄露"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#闭包引起的内存泄露"}},[e._v("#")]),e._v(" 闭包引起的内存泄露")]),e._v(" "),n("p",[e._v("原因:闭包可以读取函数内部的变量，然后让这些变量始终保存在变量中。如果在使用结束后没有将局部变量清除，就可能导致内存泄露。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('function fn () { \n  var a = "I\'m a";  \n    return \n  function () {    \n    console.log(a)  \n    }\n  }\n')])])]),n("p",[n("code",[e._v("解决")]),e._v("：将事件处理函数定义在外部，解除闭包，或者在定义事件处理的函数的外部函数中。")]),e._v(" "),n("p",[n("code",[e._v("比如")]),e._v("：在循环中的函数表达式，能复用最好放在循环外面。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// bad\nfor (var k = 0; k < 10; k++) { \n      var t = function (a) {    \n      // 创建了10次  函数对象。    \n      console.log(a) \n      } \n    t(k)} \n// good\nfunction t(a) {  \n  console.log(a)}\n  for (var k = 0; k < 10; k++) { \n    t(k)}t = null\n  }\n")])])]),n("h2",{attrs:{id:"没有清理的dom元素引用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#没有清理的dom元素引用"}},[e._v("#")]),e._v(" 没有清理的DOM元素引用")]),e._v(" "),n("p",[n("code",[e._v("原因")]),e._v("：虽然别的地方删除了，但是对象中还存在对dom的引用。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// 在对象中引用DOM\nvar elements = {  \n     btn: document.getElementById('btn')\n}\nfunction doSomeThing() { \n     elements.btn.click()\n} \nfunction removeBtn() {  \n// 将body中的btn移除, 也就是移除 DOM树中的btn  \n   document.body.removeChild(document.getElementById('button')) \n// 但是此时全局变量elements还是保留了对btn的引用, btn还是存在于内存中,不能被GC回收\n}\n")])])]),n("p",[n("code",[e._v("解决方法")]),e._v("：手动删除，elements.btn = null")]),e._v(" "),n("h2",{attrs:{id:"被遗忘的定时器或者回调"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#被遗忘的定时器或者回调"}},[e._v("#")]),e._v(" 被遗忘的定时器或者回调")]),e._v(" "),n("p",[e._v("定时器中有dom的引用，即使dom删除了，但是定时器还在，所以内存中还是有这个dom。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// 定时器\nvar serverData = loadData()setInterval(\nfunction () {  \n  var renderer = document.getElementById('renderer')  \n  if (renderer) {    \n      renderer.innerHTML = JSON.stringify(serverData)  \n  }}, 5000) \n  // 观察者模式\n var btn = document.getElementById('btn')\n function onClick(element) {  \n    element.innerHTMl = \"I'm innerHTML\"\n  }\n btn.addEventListener('click', onClick)\n")])])]),n("p",[n("code",[e._v("解决方法")]),e._v("：")]),e._v(" "),n("ul",[n("li",[e._v("手动删除定时器和dom。")]),e._v(" "),n("li",[n("code",[e._v("removeEventListener")]),e._v("移除事件监听。")])]),e._v(" "),n("h2",{attrs:{id:"vue中容易出现内存泄露的几种情况"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vue中容易出现内存泄露的几种情况"}},[e._v("#")]),e._v(" vue中容易出现内存泄露的几种情况")]),e._v(" "),n("p",[e._v("在Vue SPA开发应用中，那么就更要当心内存泄露的问题。因为在SPA的设计中，用户使用它时是不需要刷新浏览器的，所以在JavaScript应用需要自行清理组件来确保垃圾回收以预期的方式生效。因此开发过程中，你需要时刻警惕内存泄露的问题。")]),e._v(" "),n("h2",{attrs:{id:"全局变量在成的内存泄露"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#全局变量在成的内存泄露"}},[e._v("#")]),e._v(" 全局变量在成的内存泄露")]),e._v(" "),n("p",[e._v("声明的全局变量在切换页面的时候没有清空")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("<template>  \n   <div id=\"home\">这里是首页</div>\n</template>\n\n<script>  \n export default {    \n   mounted() {      \n     window.test = {        \n        // 此处在全局window对象中引用了本页面的dom对象 \n        name: 'home',        \n        node: document.getElementById('home')     \n      }    \n    }  \n  }\n<\/script>\n")])])]),n("p",[n("code",[e._v("解决方案")]),e._v("：在页面卸载的时候顺便处理掉该应用。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("destroyed () { \n   // 页面卸载的时候解除引用\n   window.test = null \n}\n\n")])])]),n("h2",{attrs:{id:"监听在window-body等事件没有解绑"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#监听在window-body等事件没有解绑"}},[e._v("#")]),e._v(" 监听在window/body等事件没有解绑")]),e._v(" "),n("p",[e._v("特别注意window.addEventListener之类的时间监听")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("<template>\n  <div id=\"home\">\n   这里是首页\n  </div>\n</template>\n\n<script>\n export default {\n   mounted () {  \n     // window对象引用了home页面的方法\n     window.addEventListener('resize', this.func)\n    }\n  }\n<\/script>\n")])])]),n("p",[n("code",[e._v("解决方法")]),e._v("：在页面销毁的时候，顺便解除引用，释放内存。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("mounted () {  \n  window.addEventListener('resize', this.func)\n},\nbeforeDestroy () { \n  window.removeEventListener('resize', this.func)\n}\n\n")])])]),n("h2",{attrs:{id:"绑在eventbus的事件没有解绑"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#绑在eventbus的事件没有解绑"}},[e._v("#")]),e._v(" 绑在EventBus的事件没有解绑")]),e._v(" "),n("p",[e._v("举个粒子🌰")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("<template>  \n  <div id=\"home\">这里是首页</div>\n</template>\n <script>\n  export default {  \n    mounted () {   \n       this.$EventBus.$on('homeTask', res => this.func(res))  \n    }}\n<\/script>\n")])])]),n("p",[n("code",[e._v("解决方法")]),e._v("：在页面卸载的时候也可以考虑引用")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("mounted () { \n   this.$EventBus.$on('homeTask', res => this.func(res))\n},\n\ndestroyed () { \n   this.$EventBus.$off()\n}\n")])])]),n("h2",{attrs:{id:"echarts"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#echarts"}},[e._v("#")]),e._v(" Echarts")]),e._v(" "),n("p",[e._v("每一个图例在没有数据的时候它会创建一个定时器去渲染气泡，页面切换后，echarts 图例是销毁了，但是这个 echarts 的实例还在内存当中，同时它的气泡渲染定时器还在运行。这就导致 Echarts 占用 CPU 高，导致浏览器卡顿，当数据量比较大时甚至浏览器崩溃。")]),e._v(" "),n("p",[n("code",[e._v("解决方法")]),e._v("：加一个 beforeDestroy()方法释放该页面的 chart 资源，我也试过使用 dispose()方法，但是 dispose 销毁这个图例，图例是不存在了，但图例的 resize()方法会启动，则会报没有 resize 这个方法，而 clear()方法则是清空图例数据，不影响图例的 resize，而且能够释放内存，切换的时候就很顺畅了")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("beforeDestroy () {  this.chart.clear()}\n\n")])])]),n("h2",{attrs:{id:"v-if-指令产生的内存泄露"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#v-if-指令产生的内存泄露"}},[e._v("#")]),e._v(" v-if 指令产生的内存泄露")]),e._v(" "),n("p",[e._v("v-if 绑定到 false 的值，但是实际上 dom 元素在隐藏的时候没有被真实的释放掉。")]),e._v(" "),n("p",[e._v("比如下面的示例中，我们加载了一个带有非常多选项的选择框，然后我们用到了一个显示/隐藏按钮，通过一个 v-if 指令从虚拟 DOM 中添加或移除它。这个示例的问题在于这个 v-if 指令会从 DOM 中移除父级元素，但是我们并没有清除由 Choices.js 新添加的 DOM 片段，从而导致了内存泄漏。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('<div id="app">\n  <button v-if="showChoices" @click="hide">Hide</button>\n  <button v-if="!showChoices" @click="show">Show</button>  \n  <div v-if="showChoices" />\n</div>\n\n<script>  \nexport default {    \n  data() {      \n    return {        \n             showChoices: true,\n            }    \n      },    \n  mounted: function () {\n          this.initializeChoices()\n     },    \n  methods: {      \n    initializeChoices: function () { \n      // 我们来为选择框载入很多选项，这样的话它会占用\n      let list = [] \n    }\n  } \n}  \n<\/script>    \n')])])]),n("p",[e._v("在上述的示例中，我们可以用 hide() 方法在将选择框从 DOM 中移除之前做一些清理工作，来解决内存泄露问题。为了做到这一点，我们会在 Vue 实例的数据对象中保留一个属性，并会使用 Choices API 中的 destroy() 方法将其清除。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('<div id="app">  \n<button v-if="showChoices" @click="hide">Hide</button> \n <button v-if="!showChoices" @click="show">Show</button> \n <div v-if="showChoices">   \n <select id="choices-single-default"></select> \n </div>\n</div>\n <script>  \n export default {    \n   data() {      \n     return {       \n           showChoices: true,       \n           choicesSelect: null     \n        }    \n       },    \n  mounted: function () {\n    this.initializeChoices()    \n  },    \n  methods: {      \n    initializeChoices: function () {\n        let list = []        \n        for (let i = 0; i < 1000; i++) { \n            list.push({            \n                label: \'Item \' + i,\n                value: i,         \n               })        \n            }         \n    // 在我们的 Vue 实例的数据对象中设置一个 `choicesSelect` 的引用this.choicesSelect = new Choices("#choices-single-default", {\n       searchEnabled: true,\n       removeItemButton: true,         \n       choices: list,       \n      })     \n    },      \n    show: function () {       \n       this.showChoices = true        \n       this.$nextTick(() => {\n           this.initializeChoices()       \n          })      \n        },     \n    hide: function () {  \n    // 现在我们可以让 Choices 使用这个引用，从 DOM 中移除这些元素之前进行清理工作   this.choicesSelect.destroy()        \n       this.showChoices = false     \n       }\n<\/script>\n')])])]),n("h2",{attrs:{id:"es6防止内存泄露"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#es6防止内存泄露"}},[e._v("#")]),e._v(" ES6防止内存泄露")]),e._v(" "),n("p",[e._v("前面说过，及时清除引用非常重要。但是，你不可能记得那么多，有时候一疏忽就忘了，所以才有那么多内存泄漏。\nES6 考虑到这点，推出了两种新的数据结构：weakset 和 weakmap 。他们对值的引用都是不计入垃圾回收机制的，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("  const wm = new WeakMap()\n  const element = document.getElementById('example')\n  vm.set(element, 'something')\n  vm.get(element)\n")])])]),n("p",[e._v("上面代码中，先新建一个 Weakmap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对 element 的引用就是弱引用，不会被计入垃圾回收机制。\n注册监听事件的 listener 对象很适合用 WeakMap 来实现。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// 代码\n1.ele.addEventListener('click', handler, false) \n// 代码\n2.const listener = new WeakMap()\n  listener.set(ele, handler)\n  ele.addEventListener('click', listener.get(ele), false)\n")])])]),n("p",[e._v("代码 2 比起代码 1 的好处是：由于监听函数是放在 WeakMap 里面，一旦 dom 对象 ele 消失，与它绑定的监听函数 handler 也会自动消失。")])])}),[],!1,null,null,null);t.default=s.exports}}]);