(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{401:function(t,e,a){"use strict";a.r(e);var d=a(1),o=Object(d.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"前言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),a("p",[t._v("在学习vue的过程种,只是知道了怎么使用它,并没有对他的原理进行了解,最近看了一些源码和一些博主的讲解,所以做了笔记以便日后复习和了解.")]),t._v(" "),a("h2",{attrs:{id:"diff的由来"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#diff的由来"}},[t._v("#")]),t._v(" diff的由来")]),t._v(" "),a("p",[t._v("vue实现双向绑定的原理，实现了视图层和数据层的同时更新，在数据层发生变化的时候利用虚拟dom去更新对应的dom树，那么新的dom树和旧的得dom树如何去对比，dom-diff主要就是用来dom得更新，将新旧得dom树进行比较然后更新.")]),t._v(" "),a("h2",{attrs:{id:"如何实现dom得更新"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何实现dom得更新"}},[t._v("#")]),t._v(" 如何实现dom得更新")]),t._v(" "),a("p",[t._v("vue的dom-diff也叫patch，意思就是打补丁，核心思想就是将旧的vnode修补得到新的vnode，然后完成渲染，总而言之，dom-diff其实就干了三件事\n1、创建节点：新的vnode中有而旧的vnode里面没有，就在旧的的vnode里面创建。\n2、删除节点：新的vnode里面没有而旧的vnode里面有，就从旧的vnode中删除。\n3、更新节点：新的vnode和就的vnode中都有，就以新的vnode为准，更新旧的vnode。")]),t._v(" "),a("h2",{attrs:{id:"下面详细说一下具体怎么实现。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#下面详细说一下具体怎么实现。"}},[t._v("#")]),t._v(" 下面详细说一下具体怎么实现。")]),t._v(" "),a("h2",{attrs:{id:"_1、创建节点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、创建节点"}},[t._v("#")]),t._v(" 1、创建节点")]),t._v(" "),a("p",[t._v("VNode类中具有6种类型的节点，但是实际只有三种类型的节点能够被创建\n(1)元素节点\n(2)文本节点\n(3)注释节点\n解析：\n1.首先判断该节点是不是元素节点吗，只需要判断VNode节点中是不是含有tag标签即可，如果存在tag标签，那么该节点一定是元素节点调用createElement方法创建元素节点\n2.判断是不是注释节点，因为在VNode类中对于注释节点有一个特殊的标记isComment，我们只需要判断isComment是不是true，如果是则调用createComment方法创建注释节点\n3.使用排除法，如果以上两个条件都不满足那么他就一定是文本节点，则调用createTextNode方法创建文本节点，再插入到DOM中。")]),t._v(" "),a("h2",{attrs:{id:"_2、删除节点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、删除节点"}},[t._v("#")]),t._v(" 2、删除节点")]),t._v(" "),a("p",[t._v("如果新的虚拟DOM树上不具有的节点，但是旧的DOM树上却有，那么我们就需要把这些节点从旧的虚拟DOM中删除，删除节点我们只需要调用删除节点父元素的removeChild方法")]),t._v(" "),a("h2",{attrs:{id:"_3、更新节点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、更新节点"}},[t._v("#")]),t._v(" 3、更新节点")]),t._v(" "),a("p",[t._v("更新节点之前我们需要将新DOM树和旧DOM树进行一个比对，当然在比对的过程中一定会存在很多的静态节点何为静态节点？\n静态节点其实就是我们写死的一些文字，没有任何可变的变量，不管数据如何变化，都和这个节点无关，这样的节点就成为DOM树上的静态节点")]),t._v(" "),a("h2",{attrs:{id:"vue的虚拟dom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue的虚拟dom"}},[t._v("#")]),t._v(" vue的虚拟dom")]),t._v(" "),a("p",[t._v("对于虚拟dom来说  它的渲染速度并不能比直接修改的dom的速度快，但是在复杂视图情况下提升渲染性能,因为\n虚拟DOM+Diff算法可以精准找到DOM树变更的地方,减少DOM的操作(重排重绘)，此时虚拟dom的性能更好 ，因为创建一个新dom开销太大了")])])}),[],!1,null,null,null);e.default=o.exports}}]);